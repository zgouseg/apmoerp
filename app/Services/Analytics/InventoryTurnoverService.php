<?php

declare(strict_types=1);

namespace App\Services\Analytics;

use App\Services\DatabaseCompatibilityService;
use Illuminate\Support\Facades\DB;

/**
 * InventoryTurnoverService - Analyze inventory turnover rates
 *
 * Provides metrics to understand how quickly inventory moves:
 * - Turnover rate (how many times inventory is sold per period)
 * - Days to sell (average days to sell inventory)
 * - Dead stock identification
 * - Overstocked items
 *
 * SECURITY NOTE: All raw SQL expressions in this service use only hardcoded column names.
 * The $periodExpr is generated by DatabaseCompatibilityService which returns hardcoded
 * SQL expressions based on the database driver. Parameters like $branchId are passed
 * through where() with proper binding. No user input is interpolated into SQL expressions.
 */
class InventoryTurnoverService
{
    public function __construct(
        protected DatabaseCompatibilityService $dbCompat
    ) {}

    /**
     * Get inventory turnover analysis
     * V35-HIGH-03 FIX: Use sale_items.cost_price (historical cost) instead of products.cost
     * V35-HIGH-02 FIX: Use sale_date instead of created_at
     * V35-MED-06 FIX: Exclude soft-deleted sales and non-revenue statuses
     */
    public function getTurnoverAnalysis(?int $branchId = null, int $days = 30): array
    {
        $startDate = now()->subDays($days);

        // Get COGS for the period
        // V35-HIGH-03 FIX: Use sale_items.cost_price (historical cost at time of sale)
        // V35-HIGH-02 FIX: Use sale_date instead of created_at
        // V35-MED-06 FIX: Exclude soft-deleted sales and non-revenue statuses
        $cogsQuery = DB::table('sale_items')
            ->join('sales', 'sale_items.sale_id', '=', 'sales.id')
            ->join('products', 'sale_items.product_id', '=', 'products.id')
            ->whereNull('sales.deleted_at')
            ->whereNotIn('sales.status', ['draft', 'cancelled', 'void', 'voided', 'returned', 'refunded'])
            ->where('sales.sale_date', '>=', $startDate);

        if ($branchId) {
            $cogsQuery->where('sales.branch_id', $branchId);
        }

        $cogs = $cogsQuery->sum(DB::raw('sale_items.quantity * COALESCE(sale_items.cost_price, products.cost, 0)'));

        // Get average inventory value
        $inventoryQuery = DB::table('products')
            ->where('status', 'active');

        if ($branchId) {
            $inventoryQuery->where('branch_id', $branchId);
        }

        $avgInventoryValue = $inventoryQuery->sum(DB::raw('COALESCE(stock_quantity, 0) * COALESCE(cost, 0)'));

        // Calculate turnover rate
        $turnoverRate = $avgInventoryValue > 0 ? ($cogs / $avgInventoryValue) : 0;
        $daysToSell = $turnoverRate > 0 ? round($days / $turnoverRate) : 0;

        return [
            'cogs' => round($cogs, 2),
            'average_inventory_value' => round($avgInventoryValue, 2),
            'turnover_rate' => round($turnoverRate, 2),
            'days_to_sell' => $daysToSell,
            'period_days' => $days,
            'rating' => $this->getTurnoverRating($turnoverRate, $days),
            'currency' => setting('general.default_currency', 'EGP'),
        ];
    }

    /**
     * Get turnover by product
     * V35-HIGH-03 FIX: Use sale_items.cost_price (historical cost) instead of products.cost
     * V35-HIGH-02 FIX: Use sale_date instead of created_at
     * V35-MED-06 FIX: Exclude soft-deleted sales and non-revenue statuses
     * V35-MED-07 FIX: Use proper bindings instead of raw SQL string interpolation
     */
    public function getProductTurnover(?int $branchId = null, int $days = 30, int $limit = 20): array
    {
        $startDate = now()->subDays($days)->toDateString();

        // Build the sales data subquery using Query Builder with proper bindings
        $salesSubquery = DB::table('sale_items')
            ->join('sales', 'sale_items.sale_id', '=', 'sales.id')
            ->join('products as p', 'sale_items.product_id', '=', 'p.id')
            ->select(
                'sale_items.product_id',
                DB::raw('SUM(sale_items.quantity) as sold_qty'),
                DB::raw('SUM(sale_items.quantity * COALESCE(sale_items.cost_price, p.cost, 0)) as cogs')
            )
            ->whereNull('sales.deleted_at')
            ->whereNotIn('sales.status', ['draft', 'cancelled', 'void', 'voided', 'returned', 'refunded'])
            ->whereDate('sales.sale_date', '>=', $startDate)
            ->groupBy('sale_items.product_id');

        $query = DB::table('products')
            ->leftJoinSub($salesSubquery, 'sales_data', function ($join) {
                $join->on('products.id', '=', 'sales_data.product_id');
            })
            ->select([
                'products.id',
                'products.name',
                'products.sku',
                'products.stock_quantity',
                'products.cost',
                DB::raw('COALESCE(products.stock_quantity, 0) * COALESCE(products.cost, 0) as inventory_value'),
                DB::raw('COALESCE(sales_data.sold_qty, 0) as sold_qty'),
                DB::raw('COALESCE(sales_data.cogs, 0) as cogs'),
                DB::raw('CASE 
                    WHEN COALESCE(products.stock_quantity, 0) * COALESCE(products.cost, 0) > 0 
                    THEN COALESCE(sales_data.cogs, 0) / (COALESCE(products.stock_quantity, 0) * COALESCE(products.cost, 0))
                    ELSE 0 
                END as turnover_rate'),
            ])
            ->where('products.status', 'active')
            ->orderByDesc('turnover_rate')
            ->limit($limit);

        if ($branchId) {
            $query->where('products.branch_id', $branchId);
        }

        return [
            'products' => $query->get()->toArray(),
            'period_days' => $days,
            'currency' => setting('general.default_currency', 'EGP'),
        ];
    }

    /**
     * Identify dead stock (items with no sales)
     * V35-HIGH-02 FIX: Use sale_date instead of created_at
     * V35-MED-06 FIX: Exclude soft-deleted sales and non-revenue statuses
     * V35-MED-07 FIX: Use proper bindings instead of raw SQL string interpolation
     */
    public function getDeadStock(?int $branchId = null, int $days = 90, int $limit = 20): array
    {
        $startDate = now()->subDays($days)->toDateString();

        // Build the recent sales subquery using Query Builder with proper bindings
        $recentSalesSubquery = DB::table('sale_items')
            ->join('sales', 'sale_items.sale_id', '=', 'sales.id')
            ->select('sale_items.product_id')
            ->whereNull('sales.deleted_at')
            ->whereNotIn('sales.status', ['draft', 'cancelled', 'void', 'voided', 'returned', 'refunded'])
            ->whereDate('sales.sale_date', '>=', $startDate)
            ->distinct();

        $query = DB::table('products')
            ->leftJoinSub($recentSalesSubquery, 'recent_sales', function ($join) {
                $join->on('products.id', '=', 'recent_sales.product_id');
            })
            ->select([
                'products.id',
                'products.name',
                'products.sku',
                'products.stock_quantity',
                'products.cost',
                DB::raw('COALESCE(products.stock_quantity, 0) * COALESCE(products.cost, 0) as tied_up_value'),
                'products.created_at',
            ])
            ->whereNull('recent_sales.product_id')
            ->where('products.status', 'active')
            ->where('products.stock_quantity', '>', 0)
            ->orderByDesc(DB::raw('COALESCE(products.stock_quantity, 0) * COALESCE(products.cost, 0)'))
            ->limit($limit);

        if ($branchId) {
            $query->where('products.branch_id', $branchId);
        }

        $products = $query->get();
        $totalValue = $products->sum('tied_up_value');

        return [
            'products' => $products->toArray(),
            'total_count' => $products->count(),
            'total_tied_up_value' => round($totalValue, 2),
            'period_days' => $days,
            'currency' => setting('general.default_currency', 'EGP'),
        ];
    }

    /**
     * Identify overstocked items
     * V35-HIGH-02 FIX: Use sale_date instead of created_at
     * V35-MED-06 FIX: Exclude soft-deleted sales and non-revenue statuses
     * V35-MED-07 FIX: Use proper bindings instead of raw SQL string interpolation
     */
    public function getOverstockedItems(?int $branchId = null, float $threshold = 3.0, int $limit = 20): array
    {
        // Threshold: months of supply (stock_qty / monthly_sales)
        $monthlySalesStart = now()->subDays(30)->toDateString();

        // Build the monthly sales subquery using Query Builder with proper bindings
        $monthlySalesSubquery = DB::table('sale_items')
            ->join('sales', 'sale_items.sale_id', '=', 'sales.id')
            ->select(
                'sale_items.product_id',
                DB::raw('SUM(sale_items.quantity) as monthly_sales')
            )
            ->whereNull('sales.deleted_at')
            ->whereNotIn('sales.status', ['draft', 'cancelled', 'void', 'voided', 'returned', 'refunded'])
            ->whereDate('sales.sale_date', '>=', $monthlySalesStart)
            ->groupBy('sale_items.product_id');

        $query = DB::table('products')
            ->leftJoinSub($monthlySalesSubquery, 'sales_data', function ($join) {
                $join->on('products.id', '=', 'sales_data.product_id');
            })
            ->select([
                'products.id',
                'products.name',
                'products.sku',
                'products.stock_quantity',
                'products.cost',
                DB::raw('COALESCE(products.stock_quantity, 0) * COALESCE(products.cost, 0) as inventory_value'),
                DB::raw('COALESCE(sales_data.monthly_sales, 0) as monthly_sales'),
                DB::raw('CASE 
                    WHEN COALESCE(sales_data.monthly_sales, 0) > 0 
                    THEN COALESCE(products.stock_quantity, 0) / sales_data.monthly_sales
                    ELSE 999
                END as months_of_supply'),
            ])
            ->where('products.status', 'active')
            ->where('products.stock_quantity', '>', 0)
            ->having('months_of_supply', '>', $threshold)
            ->orderByDesc('inventory_value')
            ->limit($limit);

        if ($branchId) {
            $query->where('products.branch_id', $branchId);
        }

        return [
            'products' => $query->get()->toArray(),
            'threshold_months' => $threshold,
            'currency' => setting('general.default_currency', 'EGP'),
        ];
    }

    /**
     * Get turnover by category
     * V35-HIGH-03 FIX: Use sale_items.cost_price (historical cost) instead of products.cost
     * V35-HIGH-02 FIX: Use sale_date instead of created_at
     * V35-MED-06 FIX: Exclude soft-deleted sales and non-revenue statuses
     * V35-MED-07 FIX: Use proper bindings instead of raw SQL string interpolation
     */
    public function getCategoryTurnover(?int $branchId = null, int $days = 30): array
    {
        $startDate = now()->subDays($days)->toDateString();

        // Build the COGS subquery using Query Builder with proper bindings
        $cogsSubquery = DB::table('sale_items')
            ->join('sales', 'sale_items.sale_id', '=', 'sales.id')
            ->join('products as p', 'sale_items.product_id', '=', 'p.id')
            ->select(
                'sale_items.product_id',
                DB::raw('SUM(sale_items.quantity * COALESCE(sale_items.cost_price, p.cost, 0)) as cogs')
            )
            ->whereNull('sales.deleted_at')
            ->whereNotIn('sales.status', ['draft', 'cancelled', 'void', 'voided', 'returned', 'refunded'])
            ->whereDate('sales.sale_date', '>=', $startDate)
            ->groupBy('sale_items.product_id');

        $query = DB::table('products')
            ->leftJoin('product_categories', 'products.category_id', '=', 'product_categories.id')
            ->leftJoinSub($cogsSubquery, 'sales_data', function ($join) {
                $join->on('products.id', '=', 'sales_data.product_id');
            })
            ->select([
                'product_categories.id',
                DB::raw('COALESCE(product_categories.name, \'Uncategorized\') as name'),
                DB::raw('COUNT(products.id) as product_count'),
                DB::raw('SUM(COALESCE(products.stock_quantity, 0) * COALESCE(products.cost, 0)) as inventory_value'),
                DB::raw('SUM(COALESCE(sales_data.cogs, 0)) as cogs'),
                DB::raw('CASE 
                    WHEN SUM(COALESCE(products.stock_quantity, 0) * COALESCE(products.cost, 0)) > 0 
                    THEN SUM(COALESCE(sales_data.cogs, 0)) / SUM(COALESCE(products.stock_quantity, 0) * COALESCE(products.cost, 0))
                    ELSE 0 
                END as turnover_rate'),
            ])
            ->where('products.status', 'active')
            ->groupBy('product_categories.id', 'product_categories.name')
            ->orderByDesc('turnover_rate');

        if ($branchId) {
            $query->where('products.branch_id', $branchId);
        }

        return [
            'categories' => $query->get()->toArray(),
            'period_days' => $days,
            'currency' => setting('general.default_currency', 'EGP'),
        ];
    }

    /**
     * Get turnover rating
     */
    protected function getTurnoverRating(float $rate, int $days): array
    {
        // Annualize the rate
        $annualRate = $rate * (365 / $days);

        if ($annualRate >= 12) {
            return ['score' => 'excellent', 'label' => __('Excellent'), 'color' => 'green'];
        } elseif ($annualRate >= 6) {
            return ['score' => 'good', 'label' => __('Good'), 'color' => 'blue'];
        } elseif ($annualRate >= 4) {
            return ['score' => 'average', 'label' => __('Average'), 'color' => 'yellow'];
        } elseif ($annualRate >= 2) {
            return ['score' => 'low', 'label' => __('Low'), 'color' => 'orange'];
        } else {
            return ['score' => 'poor', 'label' => __('Poor'), 'color' => 'red'];
        }
    }
}
