<?php

declare(strict_types=1);

namespace App\Livewire\Reports;

use App\Models\Sale;
use App\Models\SaleItem;
use App\Services\DatabaseCompatibilityService;
use Carbon\Carbon;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Livewire\Attributes\Layout;
use Livewire\Component;

/**
 * Sales Analytics Report Component
 *
 * SECURITY (V37-SQL-05): SQL Expression Safety
 * =============================================
 * This component uses selectRaw() and groupBy() with variable interpolation.
 * All interpolated values are safe because:
 *
 * 1. $dateFormat/$periodExpr: Generated by DatabaseCompatibilityService methods
 *    (monthTruncateExpression, weekTruncateExpression, dateExpression) which return
 *    hardcoded SQL expressions based on the database driver. See DatabaseCompatibilityService
 *    class documentation for details.
 *
 * 2. $hourExpr: Generated by DatabaseCompatibilityService::hourExpression() with
 *    a hardcoded column name ('created_at'). No user input is involved.
 *
 * 3. Column names used (sale_date, created_at, total_amount, etc.) are all hardcoded
 *    in the codebase and never derived from user input.
 *
 * Static analysis tools may flag these patterns as SQL injection risks. This is a
 * false positive - the expressions are constructed from hardcoded SQL patterns.
 */
class SalesAnalytics extends Component
{
    #[Layout('layouts.app')]
    public string $dateRange = 'month';

    public ?string $dateFrom = null;

    public ?string $dateTo = null;

    public ?int $branchId = null;

    public bool $isAdmin = false;

    public array $summaryStats = [];

    public array $salesTrend = [];

    public array $topProducts = [];

    public array $topCustomers = [];

    public array $paymentBreakdown = [];

    public array $hourlyDistribution = [];

    public array $categoryPerformance = [];

    protected DatabaseCompatibilityService $dbService;

    public function boot(DatabaseCompatibilityService $dbService): void
    {
        $this->dbService = $dbService;
    }

    public function mount(): void
    {
        $user = Auth::user();
        if (! $user || ! $user->can('reports.sales.view')) {
            abort(403);
        }

        $this->branchId = $user->branch_id;
        // Use case-insensitive role check - seeder uses "Super Admin" (Title Case)
        $this->isAdmin = $user->hasAnyRole(['Super Admin', 'super-admin', 'Admin', 'admin']);

        $this->setDateRange();
        $this->loadAllData();
    }

    public function setDateRange(): void
    {
        $now = Carbon::now();

        switch ($this->dateRange) {
            case 'today':
                $this->dateFrom = $now->copy()->startOfDay()->toDateString();
                $this->dateTo = $now->copy()->endOfDay()->toDateString();
                break;
            case 'week':
                $this->dateFrom = $now->copy()->startOfWeek()->toDateString();
                $this->dateTo = $now->copy()->endOfWeek()->toDateString();
                break;
            case 'month':
                $this->dateFrom = $now->copy()->startOfMonth()->toDateString();
                $this->dateTo = $now->copy()->endOfMonth()->toDateString();
                break;
            case 'quarter':
                $this->dateFrom = $now->copy()->startOfQuarter()->toDateString();
                $this->dateTo = $now->copy()->endOfQuarter()->toDateString();
                break;
            case 'year':
                $this->dateFrom = $now->copy()->startOfYear()->toDateString();
                $this->dateTo = $now->copy()->endOfYear()->toDateString();
                break;
            case 'custom':
                if (! $this->dateFrom || ! $this->dateTo) {
                    $this->dateFrom = $now->copy()->startOfMonth()->toDateString();
                    $this->dateTo = $now->copy()->endOfMonth()->toDateString();
                }
                $maxDays = 365;
                $daysDiff = Carbon::parse($this->dateFrom)->diffInDays(Carbon::parse($this->dateTo));
                if ($daysDiff > $maxDays) {
                    $this->dateTo = Carbon::parse($this->dateFrom)->addDays($maxDays)->toDateString();
                }
                break;
        }
    }

    public function updatedDateRange(): void
    {
        $this->setDateRange();
        $this->loadAllData();
    }

    public function updatedDateFrom(): void
    {
        $this->dateRange = 'custom';
        $this->loadAllData();
    }

    public function updatedDateTo(): void
    {
        $this->dateRange = 'custom';
        $this->loadAllData();
    }

    /**
     * Base scoped query with proper date filtering
     * V35-HIGH-02 FIX: Use sale_date instead of created_at for accurate period filtering
     * V35-MED-06 FIX: Exclude non-revenue statuses
     */
    protected function scopedQuery()
    {
        $query = Sale::query()
            ->whereNotIn('status', ['draft', 'cancelled', 'void', 'voided', 'returned', 'refunded'])
            ->whereBetween('sale_date', [$this->dateFrom, $this->dateTo]);

        if (! $this->isAdmin && $this->branchId) {
            $query->where('branch_id', $this->branchId);
        }

        return $query;
    }

    protected function loadAllData(): void
    {
        $this->loadSummaryStats();
        $this->loadSalesTrend();
        $this->loadTopProducts();
        $this->loadTopCustomers();
        $this->loadPaymentBreakdown();
        $this->loadHourlyDistribution();
        $this->loadCategoryPerformance();
    }

    protected function loadSummaryStats(): void
    {
        $query = $this->scopedQuery();

        $totalSales = (clone $query)->sum('total_amount') ?? 0;
        $totalOrders = (clone $query)->count();
        $completedOrders = (clone $query)->where('status', 'completed')->count();
        $avgOrderValue = $totalOrders > 0 ? (float) bcdiv((string) $totalSales, (string) $totalOrders, 2) : 0;
        $totalDiscount = (clone $query)->sum('discount_amount') ?? 0;
        $totalTax = (clone $query)->sum('tax_amount') ?? 0;
        $refundedAmount = (clone $query)->where('status', 'refunded')->sum('total_amount') ?? 0;

        // V35-HIGH-02 FIX: Use sale_date instead of created_at for previous period comparison
        $prevPeriodQuery = Sale::query()
            ->whereNotIn('status', ['draft', 'cancelled', 'void', 'voided', 'returned', 'refunded'])
            ->whereBetween('sale_date', [
                Carbon::parse($this->dateFrom)->subDays(Carbon::parse($this->dateFrom)->diffInDays(Carbon::parse($this->dateTo)) + 1)->toDateString(),
                Carbon::parse($this->dateFrom)->subDay()->toDateString(),
            ]);

        if (! $this->isAdmin && $this->branchId) {
            $prevPeriodQuery->where('branch_id', $this->branchId);
        }

        $prevTotalSales = $prevPeriodQuery->sum('total_amount') ?? 0;

        if (bccomp((string) $prevTotalSales, '0', 2) > 0) {
            $diff = bcsub((string) $totalSales, (string) $prevTotalSales, 4);
            $salesGrowth = (float) bcdiv(bcmul($diff, '100', 6), (string) $prevTotalSales, 1);
        } else {
            $salesGrowth = bccomp((string) $totalSales, '0', 2) > 0 ? 100.0 : 0.0;
        }

        $completionRate = $totalOrders > 0 ? (float) bcdiv(bcmul((string) $completedOrders, '100', 4), (string) $totalOrders, 1) : 0;

        $this->summaryStats = [
            'total_sales' => $totalSales,
            'total_orders' => $totalOrders,
            'completed_orders' => $completedOrders,
            'avg_order_value' => $avgOrderValue,
            'total_discount' => $totalDiscount,
            'total_tax' => $totalTax,
            'refunded_amount' => $refundedAmount,
            'sales_growth' => $salesGrowth,
            'completion_rate' => $completionRate,
        ];
    }

    /**
     * Load sales trend data
     * V35-HIGH-02 FIX: Use sale_date instead of created_at for accurate period filtering
     * V35-MED-06 FIX: Exclude non-revenue statuses for consistent financial reporting
     *
     * SECURITY NOTE: The $dateFormat expression is generated by DatabaseCompatibilityService
     * which returns hardcoded SQL expressions based on the database driver.
     * No user input is interpolated into the SQL.
     */
    protected function loadSalesTrend(): void
    {
        $days = Carbon::parse($this->dateFrom)->diffInDays(Carbon::parse($this->dateTo));
        $groupBy = $days > 60 ? 'month' : ($days > 14 ? 'week' : 'day');

        // V35-HIGH-02 FIX: Use sale_date for database-portable date truncation
        $dateFormat = match ($groupBy) {
            'month' => $this->dbService->monthTruncateExpression('sale_date'),
            'week' => $this->dbService->weekTruncateExpression('sale_date'),
            default => $this->dbService->dateExpression('sale_date'),
        };

        // V35-HIGH-02 FIX: Use sale_date instead of created_at for filtering
        // V35-MED-06 FIX: Exclude non-revenue statuses
        $query = Sale::query()
            ->selectRaw("{$dateFormat} as period")
            ->selectRaw('SUM(total_amount) as revenue')
            ->selectRaw('COUNT(*) as orders')
            ->whereNotIn('status', ['draft', 'cancelled', 'void', 'voided', 'returned', 'refunded'])
            ->whereBetween('sale_date', [$this->dateFrom, $this->dateTo]);

        if (! $this->isAdmin && $this->branchId) {
            $query->where('branch_id', $this->branchId);
        }

        $results = $query->groupBy('period')->orderBy('period')->get();

        $this->salesTrend = [
            'labels' => $results->pluck('period')->map(function ($p) use ($groupBy) {
                try {
                    $date = Carbon::parse($p);

                    return match ($groupBy) {
                        'month' => $date->format('M Y'),
                        'week' => 'Week '.$date->format('W'),
                        default => $date->format('M d'),
                    };
                } catch (\Exception $e) {
                    return (string) $p;
                }
            })->toArray(),
            'revenue' => $results->pluck('revenue')->map(fn ($v) => (float) $v)->toArray(),
            'orders' => $results->pluck('orders')->map(fn ($v) => (int) $v)->toArray(),
        ];
    }

    /**
     * Load top products report
     * V35-HIGH-02 FIX: Use sale_date instead of created_at
     * V35-MED-06 FIX: Exclude soft-deleted sales and non-revenue statuses
     */
    protected function loadTopProducts(): void
    {
        $query = SaleItem::query()
            ->join('sales', 'sale_items.sale_id', '=', 'sales.id')
            ->join('products', 'sale_items.product_id', '=', 'products.id')
            ->select([
                'products.id',
                'products.name',
                'products.sku',
            ])
            ->selectRaw('SUM(sale_items.quantity) as total_qty')
            ->selectRaw('SUM(sale_items.line_total) as total_revenue')
            ->whereNull('sales.deleted_at')
            ->whereNotIn('sales.status', ['draft', 'cancelled', 'void', 'voided', 'returned', 'refunded'])
            ->whereBetween('sales.sale_date', [$this->dateFrom, $this->dateTo]);

        if (! $this->isAdmin && $this->branchId) {
            $query->where('sales.branch_id', $this->branchId);
        }

        $this->topProducts = $query
            ->groupBy('products.id', 'products.name', 'products.sku')
            ->orderByDesc('total_revenue')
            ->limit(10)
            ->get()
            ->map(fn ($p) => [
                'id' => $p->id,
                'name' => $p->name,
                'sku' => $p->sku,
                'quantity' => (int) $p->total_qty,
                'revenue' => (float) $p->total_revenue,
            ])
            ->toArray();
    }

    /**
     * Load top customers report
     * V35-HIGH-02 FIX: Use sale_date instead of created_at
     * V35-MED-06 FIX: Exclude soft-deleted sales and non-revenue statuses
     */
    protected function loadTopCustomers(): void
    {
        $query = Sale::query()
            ->join('customers', 'sales.customer_id', '=', 'customers.id')
            ->select([
                'customers.id',
                'customers.name',
                'customers.email',
            ])
            ->selectRaw('COUNT(sales.id) as total_orders')
            ->selectRaw('SUM(sales.total_amount) as total_spent')
            ->whereNull('sales.deleted_at')
            ->whereNotIn('sales.status', ['draft', 'cancelled', 'void', 'voided', 'returned', 'refunded'])
            ->whereBetween('sales.sale_date', [$this->dateFrom, $this->dateTo])
            ->whereNotNull('sales.customer_id');

        if (! $this->isAdmin && $this->branchId) {
            $query->where('sales.branch_id', $this->branchId);
        }

        $this->topCustomers = $query
            ->groupBy('customers.id', 'customers.name', 'customers.email')
            ->orderByDesc('total_spent')
            ->limit(10)
            ->get()
            ->map(fn ($c) => [
                'id' => $c->id,
                'name' => $c->name,
                'email' => $c->email,
                'orders' => (int) $c->total_orders,
                'total_spent' => (float) $c->total_spent,
            ])
            ->toArray();
    }

    /**
     * Load payment method breakdown
     * V35-HIGH-02 FIX: Use sale_date instead of created_at
     * V35-MED-06 FIX: Exclude non-revenue statuses (deleted_at already filtered)
     */
    protected function loadPaymentBreakdown(): void
    {
        $query = DB::table('sale_payments')
            ->join('sales', 'sale_payments.sale_id', '=', 'sales.id')
            ->select('sale_payments.payment_method')
            ->selectRaw('COUNT(*) as count')
            ->selectRaw('SUM(sale_payments.amount) as total')
            ->whereNull('sales.deleted_at')
            ->whereNotIn('sales.status', ['draft', 'cancelled', 'void', 'voided', 'returned', 'refunded'])
            ->whereBetween('sales.sale_date', [$this->dateFrom, $this->dateTo]);

        if (! $this->isAdmin && $this->branchId) {
            $query->where('sales.branch_id', $this->branchId);
        }

        $results = $query->groupBy('sale_payments.payment_method')->get();

        $this->paymentBreakdown = [
            'labels' => $results->pluck('payment_method')->map(fn ($m) => ucfirst($m ?? 'cash'))->toArray(),
            'counts' => $results->pluck('count')->map(fn ($v) => (int) $v)->toArray(),
            'totals' => $results->pluck('total')->map(fn ($v) => (float) $v)->toArray(),
        ];
    }

    /**
     * Load hourly distribution for operational insights (peak hours analysis).
     *
     * Design Note: This method intentionally uses `created_at` for hour extraction
     * while filtering by `sale_date` range. This is because:
     * - Hour extraction: Uses when orders were physically placed (created_at) for peak hours analysis
     * - Period filtering: Uses business transaction date (sale_date) for period consistency
     *
     * For example, a sale backdated to yesterday should still count towards today's peak hours
     * if it was placed during the current session.
     *
     * V35-MED-06 FIX: Exclude non-revenue statuses
     *
     * SECURITY NOTE: The $hourExpr is generated by DatabaseCompatibilityService::hourExpression()
     * which returns hardcoded SQL expressions based on the database driver.
     * No user input is interpolated into the SQL.
     */
    protected function loadHourlyDistribution(): void
    {
        $hourExpr = $this->dbService->hourExpression('created_at');

        $query = Sale::query()
            ->selectRaw("{$hourExpr} as hour")
            ->selectRaw('COUNT(*) as count')
            ->whereNotIn('status', ['draft', 'cancelled', 'void', 'voided', 'returned', 'refunded'])
            ->whereBetween('sale_date', [$this->dateFrom, $this->dateTo]);

        if (! $this->isAdmin && $this->branchId) {
            $query->where('branch_id', $this->branchId);
        }

        $results = $query->groupBy('hour')->orderBy('hour')->get()->keyBy('hour');

        $hours = [];
        $counts = [];
        for ($i = 0; $i < 24; $i++) {
            $hours[] = sprintf('%02d:00', $i);
            $counts[] = (int) ($results->get($i)?->count ?? 0);
        }

        $this->hourlyDistribution = [
            'labels' => $hours,
            'data' => $counts,
        ];
    }

    /**
     * Load category performance
     * V35-HIGH-02 FIX: Use sale_date instead of created_at
     * V35-MED-06 FIX: Exclude soft-deleted sales and non-revenue statuses
     */
    protected function loadCategoryPerformance(): void
    {
        $query = SaleItem::query()
            ->join('sales', 'sale_items.sale_id', '=', 'sales.id')
            ->join('products', 'sale_items.product_id', '=', 'products.id')
            ->leftJoin('product_categories', 'products.category_id', '=', 'product_categories.id')
            ->select([
                'product_categories.name as category_name',
            ])
            ->selectRaw('SUM(sale_items.quantity) as total_qty')
            ->selectRaw('SUM(sale_items.line_total) as total_revenue')
            ->whereNull('sales.deleted_at')
            ->whereNotIn('sales.status', ['draft', 'cancelled', 'void', 'voided', 'returned', 'refunded'])
            ->whereBetween('sales.sale_date', [$this->dateFrom, $this->dateTo]);

        if (! $this->isAdmin && $this->branchId) {
            $query->where('sales.branch_id', $this->branchId);
        }

        $results = $query
            ->groupBy('product_categories.name')
            ->orderByDesc('total_revenue')
            ->limit(10)
            ->get();

        $this->categoryPerformance = [
            'labels' => $results->pluck('category_name')->map(fn ($c) => $c ?? 'Uncategorized')->toArray(),
            'quantities' => $results->pluck('total_qty')->map(fn ($v) => (int) $v)->toArray(),
            'revenues' => $results->pluck('total_revenue')->map(fn ($v) => (float) $v)->toArray(),
        ];
    }

    public function render()
    {
        return view('livewire.reports.sales-analytics');
    }
}
